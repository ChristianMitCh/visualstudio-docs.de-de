---
title: 'CA2000: Objekte verwerfen, bevor Bereich verloren geht'
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 387f1c3d763b15cdbf9ff3cc21375958dc213058
ms.sourcegitcommit: 4bcd6abb89feff1cf8251e3ded73fdc30b67e347
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/17/2020
ms.locfileid: "81615574"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000: Objekte verwerfen, bevor Bereich verloren geht

|||
|-|-|
|TypName|DisposeObjectsBeforeLosingScope|
|CheckId|CA2000|
|Category|Microsoft.Reliability|
|Unterbrechende Änderung|Nicht unterbrechend|

## <a name="cause"></a>Ursache

Ein lokales Objekt <xref:System.IDisposable> eines Typs wird erstellt, aber das Objekt wird nicht verworfen, bevor alle Verweise auf das Objekt anicht ausreichen.

Standardmäßig analysiert diese Regel die gesamte Codebasis, aber diese ist [konfigurierbar.](#configurability)

## <a name="rule-description"></a>Regelbeschreibung

Wenn ein verwerfbares Objekt nicht explizit verworfen wird, bevor alle Verweise darauf außerhalb des gültigen Bereichs liegen, wird das Objekt zu einer unbestimmten Zeit verworfen, wenn der Garbage Collector den Finalizer des Objekts ausführt. Da möglicherweise ein Ausnahmeereignis auftritt, durch das die Ausführung des Finalizers des Objekts verhindert wird, muss das Objekt stattdessen explizit verworfen werden.

### <a name="special-cases"></a>Spezialfälle

Regel CA2000 wird nicht für lokale Objekte der folgenden Typen ausgelöst, auch wenn das Objekt nicht freigegeben ist:

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

Das Übergeben eines Objekts eines dieser Typen an einen Konstruktor und das anschließende Zuweisen zu einem Feld gibt eine *Dispose-Eigentumsübertragung* auf den neu erstellten Typ an. Das heißt, der neu erstellte Typ ist nun für die Entsorgung des Objekts verantwortlich. Wenn Der Code ein Objekt eines dieser Typen an einen Konstruktor übergibt, tritt keine Verletzung der Regel CA2000 auf, selbst wenn das Objekt nicht freigegeben wird, bevor alle Verweise darauf aneben liegen.

## <a name="how-to-fix-violations"></a>Behandeln von Verstößen

Um einen Verstoß gegen diese Regel zu beheben, rufen Sie <xref:System.IDisposable.Dispose%2A> für das Objekt auf, bevor sich alle Verweise darauf außerhalb des gültigen Bereichs befinden.

Sie können [ `using` ](/dotnet/csharp/language-reference/keywords/using-statement) die[`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) Anweisung (in Visual Basic) <xref:System.IDisposable>verwenden, um Objekte umzuschließen, die implementieren. Objekte, die auf diese Weise umschlossen werden, werden automatisch am Ende des `using` Blocks angeordnet. Die folgenden Situationen sollten oder können jedoch `using` nicht mit einer Anweisung behandelt werden:

- Um ein Einwegobjekt zurückzugeben, muss `try/finally` das Objekt `using` in einem Block außerhalb eines Blocks erstellt werden.

- Initialisieren Sie keine Elemente eines Wegwerfobjekts im Konstruktor einer `using` Anweisung.

- Wenn Konstruktoren, die nur durch einen Ausnahmehandler geschützt sind, im [Erfassungsteil `using` einer Anweisung](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement)geschachtelt sind, kann ein Fehler im äußeren Konstruktor dazu führen, dass das vom verschachtelten Konstruktor erstellte Objekt nie geschlossen wird. Im folgenden Beispiel kann ein <xref:System.IO.StreamReader> Fehler im Konstruktor dazu führen, dass das <xref:System.IO.FileStream> Objekt nie geschlossen wird. CA2000 weist in diesem Fall einen Verstoß gegen die Regel aus.

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- Dynamische Objekte sollten ein Schattenobjekt verwenden, <xref:System.IDisposable> um das Dispose-Muster von Objekten zu implementieren.

## <a name="when-to-suppress-warnings"></a>Wann Warnungen unterdrückt werden sollen

Unterdrücken Sie eine Warnung dieser Regel nur, wenn:

- Sie haben eine Methode für Ihr `Dispose`Objekt aufgerufen, die aufruft, z. B.<xref:System.IO.Stream.Close%2A>
- Die Methode, die die <xref:System.IDisposable> Warnung ausgelöst hat, gibt ein Objekt zurück, das das Objekt umschließt.
- Die Zuweisungsmethode verfügt nicht über das Eigentum am Verfügen. Das heißt, die Verantwortung für das Entsorgen des Objekts wird auf ein anderes Objekt oder einen anderen Wrapper übertragen, das in der Methode erstellt und an den Aufrufer zurückgegeben wird.

## <a name="configurability"></a>Konfigurierbarkeit

Wenn Sie diese Regel von [FxCop-Analysatoren](install-fxcop-analyzers.md) ausführen (und nicht mit Legacyanalyse), können Sie die Analyse für diese Regel konfigurieren.

### <a name="excluded-symbol-names"></a>Ausgeschlossene Symbolnamen

Sie können konfigurieren, welche Teile der Codebasis von der Analyse ausgeschlossen werden sollen. Um beispielsweise anzugeben, dass die Regel nicht für `MyType`Code innerhalb von Typen mit dem Namen ausgeführt werden soll, fügen Sie der .editorconfig-Datei in Ihrem Projekt das folgende Schlüssel-Wert-Paar hinzu:

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

Zulässige Symbolnamenformate im Optionswert (getrennt durch '|'):
  - Nur Symbolname (enthält alle Symbole mit dem Namen, unabhängig vom enthaltenden Typ oder Namespace)
  - Vollqualifizierte Namen im [Dokumentations-ID-Format](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)des Symbols . Für jeden Symbolnamen ist ein Symboltyppräfix erforderlich, z. B. "M:"-Präfix für Methoden, "T:"-Präfix für Typen, "N:"-Präfix für Namespaces usw.
  - `.ctor`für Konstruktoren `.cctor` und statische Konstruktoren

Beispiele:

| Optionswert | Zusammenfassung |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | Entspricht allen Symbolen mit dem Namen 'MyType' in der Kompilierung
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | Entspricht allen Symbolen mit dem Namen 'MyType1' oder 'MyType2' in der Kompilierung
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Entspricht der spezifischen Methode 'MyMethod' mit einer angegebenen vollqualifizierten Signatur
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Entspricht bestimmten Methoden 'MyMethod1' und 'MyMethod2' mit der jeweiligen vollqualifizierten Signatur

Sie können alle diese Optionen nur für diese Regel, für alle Regeln oder für alle Regeln in dieser Kategorie (Entwurf) konfigurieren. Weitere Informationen finden Sie unter Konfigurieren von [FxCop-Analysatoren](configure-fxcop-analyzers.md).

## <a name="related-rules"></a>Verwandte Regeln

- [CA2213: Verwerfbare Felder verwerfen](../code-quality/ca2213.md)
- [CA2202: Objekte nicht mehrmals verwerfen](../code-quality/ca2202.md)

## <a name="example"></a>Beispiel

Wenn Sie eine Methode implementieren, die ein Einwegobjekt zurückgibt, verwenden Sie einen try/finally-Block ohne catch-Block, um sicherzustellen, dass das Objekt freigegeben wird. Mit einem try/finally-Block lassen Sie Ausnahmen zu, die am Fehlerpunkt ausgelöst werden sollen, und stellen sicher, dass das Objekt verworfen wird.

In der OpenPort1-Methode kann der Aufruf zum Öffnen des SerialPorts des ISerializable-Objekts oder der Aufruf von SomeMethod fehlschlagen. Eine CA2000-Warnung wird für diese Implementierung ausgelöst.

In der OpenPort2-Methode werden zwei SerialPort-Objekte deklariert und auf NULL festgelegt:

- `tempPort` zum Testen, ob die Methodenoperationen erfolgreich ausgeführt werden.

- `port`, die für den Rückgabewert der Methode verwendet wird.

`tempPort` wird erstellt und in einem `try`-Block geöffnet. Alle anderen erforderlichen Arbeiten werden im gleichen `try`-Block ausgeführt. Am Ende des `try`-Blocks wird dem `port`-Objekt, das zurückgegeben wird, der geöffnete Port zugewiesen und das `tempPort`-Objekt wird auf `null` festgelegt.

Der `finally`-Block überprüft den Wert von `tempPort`. Wenn nicht NULL, ist eine Operation in der Methode fehlgeschlagen und `tempPort` wird geschlossen, um sicherzustellen, dass alle Ressourcen freigegeben werden. Das zurückgegebene Port-Objekt enthält das geöffnete SerialPort-Objekt, wenn die Operationen der Methode erfolgreich waren, oder es ist NULL, wenn eine Operation fehlschlug.

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>Beispiel

Standardmäßig lässt der Visual Basic-Compiler alle arithmetischen Operatoren auf Überlauf überprüfen. Daher kann jede arithmetische Visual Basic-Operation eine <xref:System.OverflowException> auslösen. Dies kann zu unerwarteten Regelverletzungen führen, z. B. CA2000. Die folgende CreateReader1-Funktion erzeugt z. B. eine CA2000-Verletzung, da der Visual Basic-Compiler einen Befehl zur Überlaufprüfung für die Hinzufügung ausgibt, die eine Ausnahme auslösen könnte, durch die der StreamReader nicht verworfen werden würde.

Um dieses zu korrigieren, können Sie das Ausgeben von Überlaufprüfungen durch den Visual Basic-Compiler im Projekt deaktivieren, oder Sie können den Code entsprechend der folgenden CreateReader2-Funktion ändern.

Um das Aussenden von Überlaufprüfungen zu deaktivieren, klicken Sie im Projektmappen-Explorer mit der rechten Maustaste auf den Projektnamen, und klicken Sie dann auf **Eigenschaften**. Klicken Sie auf **Kompilieren**, klicken Sie auf **Erweiterte Kompilierungsoptionen**, und aktivieren Sie dann **Integerüberlaufprüfungen entfernen**.

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>Weitere Informationen

- <xref:System.IDisposable>
- [Dispose-Muster](/dotnet/standard/design-guidelines/dispose-pattern)
