---
title: 'CA1303: Literale nicht als lokalisierte Parameter übergeben'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- Do not pass literals as localized parameters
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
helpviewer_keywords:
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
ms.assetid: 904d284e-76d0-4b8f-a4df-0094de8d7aac
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CPP
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: e6b4fad16bc1c4b205ea09a39af8d38e08db848f
ms.sourcegitcommit: ade07bd1cf69b8b494d171ae648cfdd54f7800d3
ms.translationtype: MT
ms.contentlocale: de-DE
ms.lasthandoff: 04/21/2020
ms.locfileid: "81649168"
---
# <a name="ca1303-do-not-pass-literals-as-localized-parameters"></a>CA1303: Literale nicht als lokalisierte Parameter übergeben

|||
|-|-|
|TypName|DoNotPassLiteralsAsLocalizedParameters|
|CheckId|CA1303|
|Kategorie|Microsoft.Globalisierung|
|Unterbrechende Änderung|Nicht unterbrechend|

## <a name="cause"></a>Ursache

Eine Methode übergibt ein Zeichenfolgenliteral als Parameter an einen .NET-Konstruktor oder eine .NET-Methode, und diese Zeichenfolge sollte lokalisierbar sein.

Diese Warnung wird ausgelöst, wenn eine Literalzeichenfolge als Wert an einen Parameter oder eine Eigenschaft übergeben wird und einer oder mehrere der folgenden Fälle wahr sind:

- Das <xref:System.ComponentModel.LocalizableAttribute> Attribut des Parameters oder der Eigenschaft ist auf true festgelegt.

- Der Name des Zeichenfolgenparameters, der an eine Console.Write- oder Console.WriteLine-Methode übergeben wird, ist entweder "value" oder "format".

Standardmäßig analysiert diese Regel die gesamte Codebasis, aber diese ist [konfigurierbar.](#excluded-type-names-with-derived-types)

Ab Version 3.0.0 des Analyzer-Pakets wird die Benennungsheuristik standardmäßig nicht mehr verwendet, aber diese ist [konfigurierbar.](#use-naming-heuristic)

## <a name="rule-description"></a>Regelbeschreibung

Zeichenfolgenliterale, die in den Quellcode eingebettet sind, sind schwer zu lokalisieren.

## <a name="how-to-fix-violations"></a>Behandeln von Verstößen

Um eine Verletzung dieser Regel zu beheben, ersetzen Sie das <xref:System.Resources.ResourceManager> Zeichenfolgenliteral durch eine Zeichenfolge, die über eine Instanz der Klasse abgerufen wird.

## <a name="when-to-suppress-warnings"></a>Wann Warnungen unterdrückt werden sollen

Es ist sicher, eine Warnung dieser Regel zu unterdrücken, wenn die Codebibliothek nicht lokalisiert wird oder wenn die Zeichenfolge nicht für den Endbenutzer oder einen Entwickler verfügbar gemacht wird, der die Codebibliothek verwendet.

Benutzer können Rauschen gegen Methoden eliminieren, die nicht lokalisierte Zeichenfolgen übergeben werden sollen, indem sie entweder den Parameter oder die Eigenschaft umbenennen oder diese Elemente als bedingt markieren.

## <a name="configurability"></a>Konfigurierbarkeit

Wenn Sie diese Regel von [FxCop-Analysatoren](install-fxcop-analyzers.md) ausführen (und nicht mit Legacy-Analysen), ist diese Regel konfigurierbar.

### <a name="excluded-type-names-with-derived-types"></a>Ausgeschlossene Typnamen mit abgeleiteten Typen

Sie können konfigurieren, welche Typen, einschließlich der abgeleiteten Typen, von der Analyse ausgeschlossen werden sollen. Um beispielsweise anzugeben, dass die Regel nicht für `MyType` Methoden innerhalb von Typen, die benannt sind, und deren abgeleitete Typen ausgeführt werden soll, fügen Sie der .editorconfig-Datei in Ihrem Projekt das folgende Schlüssel-Wert-Paar hinzu:

```ini
dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType
```

Zulässige Symbolnamenformate im Optionswert (getrennt durch '|'):

- Nur Typname (enthält alle Typen mit dem Namen, unabhängig vom enthaltenden Typ oder Namespace)
- Vollqualifizierte Namen im [Dokumentations-ID-Format](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)des `T:` Symbols mit einem optionalen Präfix.

Beispiele:

| Optionswert | Zusammenfassung |
| --- | --- |
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType` | Entspricht allen Typen mit dem Namen 'MyType' und allen abgeleiteten Typen in der Kompilierung
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType1|MyType2` | Entspricht allen Typen mit den Namen 'MyType1' oder 'MyType2' und allen abgeleiteten Typen in der Kompilierung
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS.MyType` | Entspricht dem spezifischen Typ 'MyType' mit dem angegebenen vollqualifizierten Namen und allen abgeleiteten Typen
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS1.MyType1|M:NS2.MyType2` | Entspricht bestimmten Typen 'MyType1' und 'MyType2' mit den entsprechenden vollqualifizierten Namen und allen abgeleiteten Typen

Sie können diese Option nur für diese Regel, für alle Regeln oder für alle Regeln in dieser Kategorie (Globalisierung) konfigurieren. Weitere Informationen finden Sie unter Konfigurieren von [FxCop-Analysatoren](configure-fxcop-analyzers.md).

### <a name="use-naming-heuristic"></a>Verwenden der Namensheuristik

Sie können konfigurieren, ob Parameter oder Eigenschaftennamen, die "Text", "Nachricht" oder "Beschriftung" enthalten, diese Regel auslösen.

```ini
dotnet_code_quality.CA1303.use_naming_heuristic = true
```

## <a name="example"></a>Beispiel

Das folgende Beispiel zeigt eine Methode, die eine Ausnahme auslöst, wenn eines der beiden Argumente anicht bereichweite ist. Für das erste Argument wird dem Ausnahmekonstruktor eine Literalzeichenfolge übergeben, die gegen diese Regel verstößt. Für das zweite Argument wird dem Konstruktor ordnungsgemäß <xref:System.Resources.ResourceManager>eine Zeichenfolge übergeben, die über eine abgerufen wird.

[!code-cpp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CPP/ca1303-do-not-pass-literals-as-localized-parameters_1.cpp)]
[!code-vb[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/VisualBasic/ca1303-do-not-pass-literals-as-localized-parameters_1.vb)]
[!code-csharp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CSharp/ca1303-do-not-pass-literals-as-localized-parameters_1.cs)]

## <a name="see-also"></a>Siehe auch

- [Ressourcen in Desktop-Apps](/dotnet/framework/resources/index)
- [Antrag der Gemeinschaft auf Änderung des Verhaltens](https://github.com/dotnet/roslyn-analyzers/issues/2933)
